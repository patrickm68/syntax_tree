#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative File.expand_path("../lib/syntax_tree", __dir__)

help = <<~EOF
  stree MDOE FILE

  MODE: one of "a", "ast", "d", "doc", "f", "format", "w", or "write"
  FILE: one or more paths to files to parse
EOF

if ARGV.length < 2
  warn(help)
  exit(1)
end

module SyntaxTree::CLI
  class AST
    def run(filepath)
      pp SyntaxTree.parse(File.read(filepath))
    end
  end

  class Doc
    def run(filepath)
      formatter = SyntaxTree::Formatter.new([])
      SyntaxTree.parse(File.read(filepath)).format(formatter)
      pp formatter.groups.first
    end
  end

  class Format
    def run(filepath)
      puts SyntaxTree.format(File.read(filepath))
    end
  end

  class Write
    def run(filepath)
      File.write(filepath, SyntaxTree.format(File.read(filepath)))
    end
  end
end

mode =
  case ARGV.shift
  when "a", "ast"
    SyntaxTree::CLI::AST.new
  when "d", "doc"
    SyntaxTree::CLI::Doc.new
  when "f", "format"
    SyntaxTree::CLI::Format.new
  when "w", "write"
    SyntaxTree::CLI::Write.new
  else
    warn(help)
    exit(1)
  end

queue = Queue.new
ARGV.each { |pattern| Dir[pattern].each { |filepath| queue << filepath } }

if queue.size <= 1
  filepath = queue.shift
  mode.run(filepath) if File.file?(filepath)
  return
end

count = [8, queue.size].min
threads =
  count.times.map do
    Thread.new do
      loop do
        filepath = queue.shift
        break if filepath == :exit

        mode.run(filepath) if File.file?(filepath)
      end
    end
  end

count.times { queue << :exit }
threads.each(&:join)
